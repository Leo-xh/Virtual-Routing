\section{基本RIP协议} % (fold)
\label{sec:rip}
	\subsection{协议概述} % (fold)
	\label{sub:协议概述}
		本项目中实现的RIP协议采用了RIPv1和RIPv2的协议规定的一部分，是一个基于DV算法的网络层路由协议。其主要算法是Bellman-Ford算法，路由费用以路由跳数作为度量，运行该协议的每个路由器能够计算出到其余路由器的下一跳路由以及路由费用。定义了请求报文和响应报文两种报文格式。为了尽可能避免环路和无穷计数问题，使用的机制包括毒性逆转（split-horizon with poison inverse）、触发更新（triggered update）和抑制更新（holddown）。同时使用了flush计时器进一步缓解无穷计数问题。在协议的扩展中，实现了该协议下适用的 traceRoute功能。
	% subsection 协议概述 (end)
	\subsection{算法} % (fold)
	\label{sub:算法}
		路由表计算主要基于Bellman-Ford算法。在基本的DV算法中，路由器每次收到邻居发来的路由信息时，会使用Bellman-Ford的更新公式更新自己的路由表：$$ dist_{self}(dest) = \min_{neighbour}\{dist_{neighbour}(dest) + metric(self,neighbour)\} $$ 为此，路由器需要在维护自己路由表的同时，保存邻居发来的路由表。
		\par 在RIP协议中，路由器只需保存和维护自己的路由表。在收到邻居发来的路由信息时，会将其与自己当前的路由表进行比较，而不是用所有邻居的路由表重新计算和比较。具体而言，RIP协议使用的更新公式为（假设收到邻居$nb$的路由信息）：$$ dist_{self}(dest) = \begin{cases} \min( dist_{self}(dest), dist_{nb}(dest) + metric(self,nb) ) & , nextHop_{self}(dest) \neq nb \\ dist_{nb}(dest) + metric(self,nb) & , nextHop_{self}(dest) = nb \end{cases}$$ 采用这种更新方式避免了路由器存储邻居路由表的开销，也减少了更新所需的计算量。不足之处在于最短路径费用增加时，不能马上从其余路径中找到更优的并将其替代，需要等待其他邻居发送路由信息。（事实上，为了避免环路和无穷计数问题，原最短路径费用增加后从其余路径中找替代的更新方式是不被允许的。）
		\par 
	
	% subsection 算法 (end)
	\subsection{协议特性} % (fold)
	\label{sub:协议特性}
	\subsubsection{协议流程} % (fold)
		\label{ssub:协议流程}
		本项目中实现的RIP协议主要包含的流程如下：
		\begin{itemize}
			\item 路由器在进入区域时，向所有邻居发送request报文，邻居则返回一个response报文，里面含有邻居的距离矢量表。
			\item 该路由器会定时地向所有的邻居发送response报文，即就是发送自己的距离矢量表。
			\item 收到一个response报文意味着要维持该邻居的状态；而如果在一段时间内没有收到某个邻居路由器的response报文，则认为该路由器故障或离开该区域。
			\item 当收到其它邻居路由器的距离矢量表时，根据该信息更新自己的距离矢量表；当自己的距离矢量更新时，向所有邻居发送自己新的距离矢量表。
		\end{itemize}
		% subsubsection 协议流程 (end)
	% subsection 协议特性 (end)
	\subsection{报文格式} % (fold)
	\label{sub:报文格式}
	本实验中使用的普通报文普通数据报文、request报文、response报文、TraceRoute报文、Echo报文如下：
	\par 普通报文：
	\begin{table}[H]
		\centering
		\begin{tabular}{|c|}
			\hline
			Command \\
			\hline
			source address \\
			\hline
			destination address \\
			\hline
			payload \\
			\hline
		\end{tabular}		
	\end{table}
	request报文：
	\begin{table}[H]
		\centering
		\begin{tabular}{|c|}
			\hline
			Command \; \vline \; Version \; \vline \; Routing domain \; \\
			\hline
			Source address \\
			\hline
			Address family \; \vline \; Route tag \; \\
			\hline
			address \\
			\hline
			Next hop \\
			\hline
			metric \\
			\hline
		\end{tabular}
	\end{table}
	Response报文：
	\begin{table}[H]
		\centering
		\begin{tabular}{|c|}
			\hline
			Command \; \vline \; Version \; \vline \; Routing domain \; \\
			\hline
			Source address \\
			\hline
			Address family \; \vline \; Route tag \; \\
			\hline
			address \\
			\hline
			Next hop \\
			\hline
			metric \\
			\hline
			repeat of last 17 bytes \\
			\hline
			$\cdots$ \\
			\hline 
		\end{tabular}	
	\end{table}
	TraceRoute报文：
	\begin{table}[H]
	\centering
		\begin{tabular}{|c|}
			\hline
			Command \\
			\hline
			source address \\
			\hline
			destination address \\
			\hline
			count \\
			\hline
		\end{tabular}		
	\end{table}	
	Echo 报文：
	\begin{table}[H]
	\centering
		\begin{tabular}{|c|}
			\hline
			Command \\
			\hline
			source address \\
			\hline
			destination address \\
			\hline
			local address \\
			\hline
		\end{tabular}		
	\end{table}
	报文项解释：
	\begin{enumerate}
		\item Command（1 Byte）：指明这条报文的类型。
		\begin{enumerate}[]
			\item 0：普通报文。
			\item 1：请求报文。
			\item 2：响应（包含路由表）报文。
			\item 3：TraceRoute报文。
			\item 4：Echo报文。
		\end{enumerate}
		\item Version（1 Byte）：RIP协议的版本。
		\item Routing domain（2 Bytes）：指明这是RIP中的哪一步。
		\item Source address（6 Bytes）：指明发送方的源地址和监听端口。
		\item Address family（2 Bytes）：使用什么作为地址，使用IP该项为2。
		\item Route tag（2 Bytes）：本项目中不用。
		\item address（6 Bytes）：ip和端口号。
		\item Next hop（6 Bytes）：下一跳路由的ip和端口。
		\item metric（1 Byte）：代价度量（跳数）。
		\item Local address（6 Bytes）：指明Echo报文发送者的源地址和监听端口。
		\item Count(1 Byte)：路由跳数。
	\end{enumerate}
	% subsection 报文格式 (end)
	\subsection{协议扩展} % (fold)
	\label{sub:协议扩展}
		\begin{enumerate}
			\item 网络环路\\
				·路由器可能收到自己发送的路由信息，因此造成网络环路。\\
				·为了避免该情况，采用了：水平分割、毒性逆转、抑制定时器和触发更新机制。
			\item 无穷计数\\
				·采用flush计时器，在检测到一个邻居可能失效时不立即将其从数据库中删除，等待一个间隔后再删除，目的是通告其它邻居该失效邻居不可达。
			\item TraceRoute\\
				·基于RIP路由16跳不可达这一机理，向目的地发跳数为1-16共16个报文，当一个路由器收到该报文，则提取其中的跳数，并将它减一。\\
				·当跳数为0时，向报文的源地址返回一个Echo报文；否则将跳数打包进原报文中，继续向目的地转发。\\
				·源地址路由器收集所有返回的Echo报文，如果5s内收到目的地址返回的Echo报文，则输出该路径；否则认为该目的地址不可达。
		\end{enumerate}
	% subsection 协议扩展 (end)
	\subsection{协议实现} % (fold)
	\label{sub:协议实现}
		本RIP协议基本由Python实现，主要利用的是socket库进行套接字编程并采用的是UDP协议、struct库进行数据的打包和解包、threading库管理线程和定时器。
		\par 实现方法实现了一个RIP协议类，处理内部流程和为外部调用留出了收发数据、查询路由路径等接口。
	% subsection 协议实现 (end)
	\subsection{结果} % (fold)
	\label{sub:结果}
		测试所用的拓扑图以及路由结果如下图\ref{fig:ripTest1}和\ref{fig:ripTest2}所示。
		\begin{figure}[H]
			\centering
			\includegraphics[scale=0.4]{imgs/topo1/tpop1.png}
			\includegraphics[scale=0.5]{imgs/ripTest1.PNG}
			\caption{RIP测试样例一}
			\label{fig:ripTest1}
		\end{figure}
		\begin{figure}[H]
			\centering
			\includegraphics[scale=0.4]{imgs/topo1/topo2.png}
			\includegraphics[scale=0.4]{imgs/ripTest2.PNG}
			\caption{RIP测试样例二}
			\label{fig:ripTest2}
		\end{figure}
		成功找出了其中的跳数最小的路径。
	% subsection 结果 (end)
	\subsection{总结} % (fold)
	\label{sub:总结}
	
	% subsection 总结 (end)


% section rip (end)